class Env{constructor(n,t,e=null,i=null){if(null==i){this.env={};for(let e in t)this.env[n[e]]=t[e]}else this.env=i;this.outer=e}find(n){return n in this.env?this:null!=this.outer||null!=this.outer?this.outer.find(n):void 0}update(n,t){return n in this.env?(this.env[n]=t,this.env[n]):null!=this.outer||null!=this.outer?this.outer.update(n,t):void 0}create(n,t){this.env[n]=t}}class JFunctor{constructor(n,t,e){this.params=n,this.body=t,this.env=e}execute(n){const t=new Env(this.params,n,this.env,null);return Eval(this.body,t)}}class JWhile{constructor(n,t,e){this.condition=n,this.body=t,this.env=e}execute(){const n=new Env(null,null,this.env,{});for(;0!=Eval(this.condition,n);)Eval(this.body,n)}}class JFor{constructor(n,t,e,i){this.varname=n,this.list=t,this.body=e,this.env=i}execute(){const n=new Env(null,null,this.env,{});n.create(this.varname,Eval(0,n));for(let t of this.list.list)n.update(this.varname,t),Eval(this.body,n)}}class JList{constructor(n){this.list=n}}class JIf{constructor(n,t,e){this.condition=n,this.body=t,this.env=e}execute(){const n=new Env(null,null,this.env,{});1==Eval(this.condition,n)&&Eval(this.body,n)}}class JIfElse{constructor(n,t,e,i){this.condition=n,this.ifBody=t,this.elseBody=e,this.env=i}execute(){const n=new Env(null,null,this.env,{});1==Eval(this.condition,n)?Eval(this.ifBody,n):Eval(this.elseBody,n)}}class JCluster{constructor(n,t){this.body=n,this.env=new Env(null,null,t,{}),Eval(n,this.env)}find(n){}}let keywords=["begin","lambda","if","else","define","update","while","for","defun","cluster","declu","invoke","export"];function isPrimitive(n){if("number"==typeof n)return!0;if("boolean"==typeof n)return!0;if("string"==typeof n){let t=!1;if('"'==(n=(n=n.trim()).split(""))[0]){for(n.shift();'"'!=n[0];)n.shift();'"'==n[0]&&(t=!0)}return t}return n instanceof JList}function Eval(n,t){if(void 0!==n){if(!Array.isArray(n)&&isPrimitive(n)){if("string"==typeof n){const t=[];if('"'==(n=(n=n.trim()).split(""))[0]){for(n.shift();'"'!=n[0];)t.push(n.shift());'"'==n[0]&&(isString=!0)}return t.join("")}return n}if(!(Array.isArray(n)||n in keywords)){t.find(n).env[n];return t.find(n).env[n]}if("define"==n[0]){let[e,i,o]=n;return t.env[i]=Eval(o,t),t.env[i]}if("update"==n[0]){let[e,i,o]=n;return t.update(i,Eval(o,t))}if("begin"==n[0]){let[e,...i]=n,o=[];for(let n of i){const e=Eval(n,t);null!=e&&o.push(e)}return o[o.length-1]}if("while"==n[0])return[_,condition,body]=n,loop=new JWhile(condition,body,t),void loop.execute();if("for"==n[0]){[_,varname,__,list,body]=n;const e=Eval(list,t);return loop=new JFor(varname,e,body,t),void loop.execute()}if("lambda"==n[0])return[_,params,body]=n,new JFunctor(params,body,t);if("defun"==n[0])return[_,name,params,body]=n,t.env[name]=new JFunctor(params,body,t),t.env[name];if("invoke"==n[0]){[_,func,args]=n;let e=[];for(let n of args)e.push(Eval(n,t));return lfunc=Eval(func,t),lfunc.execute(e)}if("if"==n[0]&&"else"==n[3])return[_,condition,ifBlock,__,elseBlock]=n,IFELSE=new JIfElse(condition,ifBlock,elseBlock,t),void IFELSE.execute();if("if"==n[0])return[_,condition,body]=n,IF=new JIf(condition,body,t),void IF.execute();if("export"==n[0]);else{if("cluster"==n[0])return[_,body]=n,new JCluster(body,t);{let[e,...i]=n,o=Eval(e,t);if(o instanceof JCluster)return Eval(...i,o.env);let s=[];for(let n of i)s.push(Eval(n,t));if(o instanceof JFunctor)return o.execute(s);if(null!=o)return o(...s)}}}}function print(n){console.log(n)}function min(n,t){return n>t?t:n<t?n:n==t?n:void 0}function max(n,t){return n>t?n:n<t?t:n==t?n:void 0}function range(n=0,t=0,e=1){const i=[];for(let o=n;o<t;o+=e)i.push(o);return new JList(i)}const MAIN_ENV=new Env(null,null,null,{print:print,"+":(n,t)=>n+t,"++":n=>n+1,"-":(n,t)=>n-t,"*":(n,t)=>n*t,"/":(n,t)=>n/t,"**":(n,t)=>n**t,rem:(n,t)=>n%t,list:(...n)=>new JList([...n]),table:(...n)=>new JTable([...n]),"=":(n,t)=>n==t,"/=":(n,t)=>n!=t,">":(n,t)=>n>t,"<":(n,t)=>n<t,">=":(n,t)=>n>=t,"<=":(n,t)=>n<=t,min:min,max:max,and:(n,t)=>n&&t,or:(n,t)=>n||t,not:n=>!n,range:range});function iEval(n){Eval(n,MAIN_ENV)}module.exports=iEval;
